import { CVData, ShareableCVResponse } from '@/types/cv';
import { generateShareToken } from './cv-transforms';

/**
 * Share configuration options
 */
export interface ShareConfig {
  includeContactInfo: boolean;
  includePersonalProjects: boolean;
  includeVolunteerWork: boolean;
  includeCustomSections: boolean;
  watermark?: string;
}

/**
 * Default share configuration
 */
export const DEFAULT_SHARE_CONFIG: ShareConfig = {
  includeContactInfo: true,
  includePersonalProjects: true,
  includeVolunteerWork: true,
  includeCustomSections: true,
};

/**
 * Advanced CV sanitization for public sharing with custom configuration
 */
export function sanitizeCVForSharing(data: CVData, config: ShareConfig = DEFAULT_SHARE_CONFIG): CVData {
  const sanitized = { ...data };

  // Handle contact information
  if (!config.includeContactInfo) {
    sanitized.contact = {
      name: data.contact.name,
      email: '[Email Hidden]',
      phone: '[Phone Hidden]',
      location: data.contact.location,
    };
  }

  // Handle personal projects
  if (!config.includePersonalProjects) {
    sanitized.projects = [];
  }

  // Handle volunteer work
  if (!config.includeVolunteerWork) {
    sanitized.volunteerWork = [];
  }

  // Handle custom sections
  if (!config.includeCustomSections) {
    sanitized.customSections = [];
  }

  // Add watermark if specified
  if (config.watermark) {
    sanitized.customSections = [
      ...sanitized.customSections,
      {
        id: 'watermark',
        title: 'Generated by',
        content: config.watermark,
        type: 'text',
      },
    ];
  }

  // Remove sensitive metadata
  if (sanitized.metadata) {
    sanitized.metadata = {
      ...sanitized.metadata,
      atsScore: undefined,
      keywords: undefined,
      targetRole: undefined,
      targetIndustry: undefined,
    };
  }

  return sanitized;
}

/**
 * Generate share URL with custom domain support
 */
export function generateShareURL(token: string, baseUrl?: string): string {
  const base = baseUrl || process.env.NEXTAUTH_URL || 'http://localhost:3000';
  return `${base}/cv/shared/${token}`;
}

/**
 * Generate QR code data URL for sharing
 */
export function generateQRCodeData(shareUrl: string): string {
  // This would typically use a QR code library
  // For now, return a placeholder data URL
  return `data:image/svg+xml;base64,${Buffer.from(`
    <svg xmlns="http://www.w3.org/2000/svg" width="200" height="200" viewBox="0 0 200 200">
      <rect width="200" height="200" fill="white"/>
      <text x="100" y="100" text-anchor="middle" font-family="Arial" font-size="12">
        QR Code for: ${shareUrl}
      </text>
    </svg>
  `).toString('base64')}`;
}

/**
 * Create shareable CV response with analytics tracking
 */
export function createShareableResponse(
  cv: any,
  config: ShareConfig = DEFAULT_SHARE_CONFIG
): ShareableCVResponse {
  const sanitizedData = sanitizeCVForSharing(cv.data, config);
  
  return {
    cv: {
      id: cv.id,
      name: cv.name,
      template: cv.template,
      data: sanitizedData,
      createdAt: cv.createdAt.toISOString(),
      updatedAt: cv.updatedAt.toISOString(),
    },
  };
}

/**
 * Validate share token format
 */
export function isValidShareToken(token: string): boolean {
  // Share tokens should be at least 10 characters and contain only alphanumeric characters
  return /^[a-zA-Z0-9]{10,}$/.test(token);
}

/**
 * Generate share analytics data
 */
export interface ShareAnalytics {
  shareToken: string;
  viewCount: number;
  lastViewed?: Date;
  viewerLocations: string[];
  referrers: string[];
}

/**
 * Track share view (placeholder for analytics implementation)
 */
export function trackShareView(
  shareToken: string,
  viewerInfo: {
    ip?: string;
    userAgent?: string;
    referrer?: string;
    location?: string;
  }
): void {
  // This would typically log to an analytics service
  console.log('Share view tracked:', {
    shareToken,
    timestamp: new Date().toISOString(),
    ...viewerInfo,
  });
}

/**
 * Generate share metadata for social media
 */
export interface ShareMetadata {
  title: string;
  description: string;
  imageUrl?: string;
  url: string;
}

export function generateShareMetadata(
  cv: { name: string; data: CVData },
  shareUrl: string
): ShareMetadata {
  const { name, data } = cv;
  const ownerName = data.contact.name || 'Professional';
  
  return {
    title: `${name} - ${ownerName}`,
    description: data.summary || `Professional resume of ${ownerName}`,
    url: shareUrl,
    // imageUrl would typically be a generated preview image
  };
}

/**
 * Share expiration utilities
 */
export interface ShareExpiration {
  expiresAt?: Date;
  maxViews?: number;
  currentViews: number;
}

export function isShareExpired(expiration: ShareExpiration): boolean {
  if (expiration.expiresAt && expiration.expiresAt < new Date()) {
    return true;
  }
  
  if (expiration.maxViews && expiration.currentViews >= expiration.maxViews) {
    return true;
  }
  
  return false;
}

/**
 * Generate time-limited share token
 */
export function generateTimeLimitedShareToken(expirationHours: number = 24): {
  token: string;
  expiresAt: Date;
} {
  const token = generateShareToken();
  const expiresAt = new Date();
  expiresAt.setHours(expiresAt.getHours() + expirationHours);
  
  return { token, expiresAt };
}

/**
 * Share permission levels
 */
export enum SharePermission {
  VIEW_ONLY = 'view_only',
  DOWNLOAD_PDF = 'download_pdf',
  DOWNLOAD_ALL = 'download_all',
  CLONE = 'clone',
}

export interface ShareSettings {
  permissions: SharePermission[];
  config: ShareConfig;
  expiration?: ShareExpiration;
  password?: string;
  allowedDomains?: string[];
}

/**
 * Validate share access based on settings
 */
export function validateShareAccess(
  settings: ShareSettings,
  request: {
    permission: SharePermission;
    domain?: string;
    password?: string;
  }
): { allowed: boolean; reason?: string } {
  // Check permission
  if (!settings.permissions.includes(request.permission)) {
    return { allowed: false, reason: 'Permission not granted' };
  }
  
  // Check domain restriction
  if (settings.allowedDomains && request.domain) {
    const isAllowedDomain = settings.allowedDomains.some(domain =>
      request.domain?.endsWith(domain)
    );
    if (!isAllowedDomain) {
      return { allowed: false, reason: 'Domain not allowed' };
    }
  }
  
  // Check password
  if (settings.password && settings.password !== request.password) {
    return { allowed: false, reason: 'Invalid password' };
  }
  
  // Check expiration
  if (settings.expiration && isShareExpired(settings.expiration)) {
    return { allowed: false, reason: 'Share link has expired' };
  }
  
  return { allowed: true };
}